<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>手机设计工具</title>
    <!-- 预防移动设备默认的触摸行为 -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/fabric@4.6.0/dist/fabric.min.js"></script>

    <style>
        body {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            height: 100vh;
            margin: 0;
            padding: 6px;
            overflow: hidden;
            touch-action: manipulation;
        }

        .toolbar-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.95);
            z-index: 1200;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            padding: 10px;
            max-height: 45vh;
            overflow-y: auto;
            transition: all 0.3s ease;
            visibility: visible;
            opacity: 1;
            transform: translateZ(0);
            -webkit-transform: translateZ(0);
        }

        .toolbar-group {
            background: white;
            border-radius: 10px;
            padding: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            margin: 0 4px 4px 0;
            flex-shrink: 0;
        }

        .input-sm {
            min-width: 50px;
            padding: 4px 8px;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            font-size: 12px;
            flex-shrink: 1;
        }

        .touch-target {
            min-width: 44px;
            min-height: 44px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        #canvas-wrapper {
            flex: 1;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #f5f5f5;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1;
            /* 添加硬件加速，提升移动设备性能 */
            transform: translateZ(0);
            backface-visibility: hidden;
            perspective: 1000;
            -webkit-transform: translateZ(0);
            -webkit-backface-visibility: hidden;
            -webkit-perspective: 1000;
        }

        #canvas {
            touch-action: none;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            /* 硬件加速 */
            transform: translateZ(0);
            backface-visibility: hidden;
            -webkit-transform: translateZ(0);
            -webkit-backface-visibility: hidden;
            image-rendering: optimizeSpeed; /* 优化图像渲染速度 */
        }

        /* 缩放控制器样式 */
        .zoom-controls {
            position: fixed;
            bottom: 20px;
            right: 15px;
            display: flex;
            gap: 8px;
            z-index: 1000;
            pointer-events: auto;
        }

        .zoom-btn {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 20px;
            user-select: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        
        /* 增加按钮悬停效果 */
        .zoom-btn:hover {
            background: rgba(0, 0, 0, 0.85);
            transform: scale(1.05);
        }
        
        /* 确保缩放指示器始终可见 */
        .zoom-indicator {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 12px;
            border-radius: 16px;
            font-size: 14px;
            pointer-events: none;
            z-index: 1000;
        }
        
        /* 按钮分组样式 */
        .zoom-group {
            display: flex;
            gap: 8px;
        }
        
        /* 垂直按钮分组 */
        .zoom-group-vertical {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        /* 操作提示区域样式 */
        #tip-container {
            position: fixed;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 1000;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        /* 移动模式指示器 */
        #pan-indicator {
            position: fixed;
            top: 70px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 1000;
            display: none;
            pointer-events: none;
        }

        /* 切换工具栏按钮 */
        #toggleToolbar {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999 !important; /* 确保最高层级 */
            cursor: pointer;
            font-size: 16px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            user-select: none;
            touch-action: manipulation;
        }

        /* 临时使用系统字体确保样式生效 */
        @font-face {
            font-family: 'FangYuan';
            src: local('Microsoft YaHei'), local('SimHei'); /* 回退到系统字体 */
        }
        @font-face {
            font-family: 'ChenDaiMing';
            src: local('Microsoft YaHei'), local('SimHei');
        }
        @font-face {
            font-family: 'FZKaiTi';
            src: local('KaiTi'), local('SimKai'); /* 系统楷体 */
        }
        
        #toolbarContainer {
            position: fixed !important;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.98);
            z-index: 9998 !important; /* 确保高层级 */
            padding: 15px;
            box-shadow: 0 2px 15px rgba(0,0,0,0.3);
            max-height: 80vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            transition: transform 0.3s ease;
            transform: translateZ(0);
            -webkit-transform: translateZ(0);
        }
    </style>
</head>

<body class="bg-gray-50">
    <!-- 画布容器，现在是全屏的 -->
    <div id="canvas-wrapper">
        <canvas id="canvas"></canvas>
    </div>
    
    <!-- 工具栏切换按钮 - 使用button元素 -->
    <button id="toggleToolbar" style="position:fixed; top:10px; right:10px; width:60px; height:60px; border-radius:50%; background:rgba(0,0,0,0.8); color:white; display:flex; align-items:center; justify-content:center; z-index:9999; cursor:pointer; font-size:20px; box-shadow:0 4px 10px rgba(0,0,0,0.4); border:none; outline:none; padding:0;">工具</button>
    
    <!-- 新工具栏容器 (简化结构) -->
    <div id="toolbarContainer" style="display:none; position:absolute; top:0; left:0; width:100%; background:white; z-index:9990; padding:15px; box-shadow:0 5px 20px rgba(0,0,0,0.4); max-height:80vh; overflow-y:auto;">
        <div class="flex flex-wrap gap-2">
        <!-- 图形设置组 -->
            <div class="toolbar-group flex-1 min-w-[140px]">
            <div class="text-sm font-medium text-gray-700 mb-2">图形设置</div>
                <div class="flex gap-2 flex-wrap shape-controls">
                    <select id="shapeType" class="input-sm touch-target" style="min-width: 70px;">
                    <option value="rect">矩形</option>
                    <option value="circle">圆形</option>
                    <option value="triangle">三角形</option>
                    <option value="line">线条</option>
                </select>
                <!-- 矩形参数 -->
                <div id="rectParams" class="flex gap-2 flex-wrap" style="display: flex;">
                    <input type="number" id="rectWidth" placeholder="宽(mm)" class="input-sm touch-target" min="5" value="50">
                    <input type="number" id="rectHeight" placeholder="高(mm)" class="input-sm touch-target" min="5" value="30">
                </div>
                <!-- 圆形参数 -->
                <div id="circleParams" class="flex gap-2 flex-wrap" style="display: none;">
                    <input type="number" id="circleDiameter" placeholder="直径(mm)" class="input-sm touch-target" min="10" value="40">
                    <input type="number" id="circleRadius" placeholder="半径(mm)" class="input-sm touch-target" min="5" value="20" readonly style="background-color: #f3f4f6;">
                </div>
                <!-- 三角形参数 -->
                <div id="triangleParams" class="flex gap-2 flex-wrap" style="display: none;">
                    <input type="number" id="triangleBase" placeholder="底边(mm)" class="input-sm touch-target" min="5" value="50">
                    <input type="number" id="triangleHeight" placeholder="高(mm)" class="input-sm touch-target" min="5" value="30">
                </div>
                <!-- 线段参数 -->
                <div id="lineParams" class="flex gap-2 flex-wrap" style="display: none;">
                    <input type="number" id="lineLength" placeholder="长度(mm)" class="input-sm touch-target" min="10" value="60">
                </div>
                <button id="addShapeBtn" class="bg-blue-500 text-white input-sm touch-target">添加图形</button>
            </div>
        </div>

        <!-- 文字设置组 -->
            <div class="toolbar-group flex-1 min-w-[140px]">
            <div class="text-sm font-medium text-gray-700 mb-2">文字设置</div>
            <div class="flex gap-2 flex-wrap">
                <select id="fontFamily" class="input-sm touch-target">
                    <option value="FangYuan">方圆体</option>
                    <option value="ChenDaiMing">陈代明硬笔体</option>
                    <option value="FZKaiTi">方正楷体</option>
                    <option value="Microsoft YaHei">微软雅黑</option>
                </select>

                <input type="text" id="textContent" placeholder="输入文字（可双击编辑）" class="input-sm touch-target flex-1">
                <button id="addText" class="bg-blue-500 text-white input-sm touch-target">添加文字</button>

            </div>
        </div>

        <!-- 媒体功能组 -->
            <div class="toolbar-group flex-1 min-w-[140px]">
                <div class="text-sm font-medium text-gray-700 mb-2">媒体与导出</div>
            <div class="flex gap-2 flex-wrap">
                <label class="bg-green-500 text-white input-sm touch-target cursor-pointer">
                    上传图片 <input type="file" id="imageUpload" accept="image/*" class="hidden">
                </label>
                    <button id="saveBtn" class="bg-blue-600 text-white input-sm touch-target">导出为图片</button>
                <button id="deleteBtn" class="bg-red-500 text-white input-sm touch-target">删除选中</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 缩放控制按钮 -->
    <div class="zoom-controls" style="display: none;">
        <div class="zoom-group-vertical">
            <div id="zoomIn" class="zoom-btn" title="放大视图">+</div>
            <div id="zoomOut" class="zoom-btn" title="缩小视图">−</div>
        </div>
        <div class="zoom-group-vertical">
            <div id="zoomFit" class="zoom-btn" title="适应画布">⤢</div>
            <div id="zoomReset" class="zoom-btn" title="重置视图">⟲</div>
        </div>
        <div class="zoom-group-vertical">
            <div id="enlargeObject" class="zoom-btn" title="放大选中图形">↗</div>
            <div id="shrinkObject" class="zoom-btn" title="缩小选中图形">↘</div>
        </div>
    </div>
    
    <!-- 添加独立的缩放指示器 -->
    <div id="zoomIndicator" class="zoom-indicator" style="display: none;">缩放: 100%</div>

    <!-- 操作提示区域 -->
    <div id="tip-container" style="opacity: 0;">拖动元素进行位置调整</div>
    
    <!-- 移动模式指示器 -->
    <div id="pan-indicator">移动模式：拖动空白处移动画布</div>

    <script>
        const MM_TO_PIXEL = 96 / 25.4; 
        const SCALE_FACTOR = 2 / 3;

        function init() {
            // 使用动态计算屏幕尺寸，而不是固定值
            const CANVAS_WIDTH = window.innerWidth;
            const CANVAS_HEIGHT = window.innerHeight;
            
            // 移动灵敏度设置 - 可根据设备调整
            const MOVE_SENSITIVITY = window.innerWidth < 768 ? 2.0 : 1.5; // 手机上更灵敏
            console.log('移动灵敏度设置:', MOVE_SENSITIVITY);
            
            const canvasEl = document.getElementById('canvas');
            const canvas = new fabric.Canvas(canvasEl, {
                backgroundColor: 'white',
                preserveObjectStacking: true,
                selectionColor: 'rgba(59,130,246,0.1)',
                selectionBorderColor: '#3b82f6',
                width: CANVAS_WIDTH,
                height: CANVAS_HEIGHT,
                controlsAboveOverlay: true, // 确保控制点在最上层
                perPixelTargetFind: false, // 关闭精确点击检测以提高性能
                renderOnAddRemove: true, // 确保添加对象时自动渲染
                stopContextMenu: true, // 阻止右键菜单
                fireRightClick: true, // 支持右键事件
                targetFindTolerance: 5, // 点击容差，使选择更容易
                uniScaleTransform: true, // 统一缩放变换
                enableRetinaScaling: false, // 禁用视网膜缩放提高性能
                stateful: true, // 启用状态记录确保元素正确显示
                skipTargetFind: false, // 确保可选中对象
                interactive: true, // 确保画布可交互
                isDrawingMode: false, // 不是绘图模式
                allowTouchScrolling: false, // 禁止触摸滚动，允许多点触控
                // 添加触摸设备支持
                enablePointerEvents: true
            });
            
            // 确保fabric.js不会阻止原生触摸事件
            canvas.allowTouchScrolling = false;
            canvas.enableRetinaScaling = false;
            
            // 确保画布元素可以接收触摸事件
            canvasEl.style.touchAction = 'none';
            
            // 添加fabric触摸事件监听用于调试
            canvas.on('touch:longpress', function(e) {
                console.log('Fabric - 长按事件');
            });
            
            canvas.on('mouse:down', function(e) {
                if (e.e.type && e.e.type.includes('touch')) {
                    console.log('Fabric - 触摸按下，目标:', e.target ? e.target.type : '无');
                }
            });
            
            canvas.on('object:selected', function(e) {
                console.log('Fabric - 对象被选中:', e.target.type);
                tipSystem.show(`已选中${e.target.type}`);
            });
            
            // 禁用fabric的默认触摸拖动行为
            canvas.on('touch:drag', function(e) {
                if (isPanning) {
                    // 如果正在平移画布，阻止fabric的默认行为
                    e.e.preventDefault();
                    e.e.stopPropagation();
                    return false;
                }
                // 否则让fabric正常处理对象拖动
            });
            
            // 监听fabric的mouse:down事件，用于检测是否点击到对象
            let fabricTargetOnMouseDown = null;
            canvas.on('mouse:down', function(options) {
                fabricTargetOnMouseDown = options.target;
                console.log('Fabric mouse:down - 目标:', fabricTargetOnMouseDown ? '有对象' : '无对象');
            });

            // 缩放相关变量
            let zoomLevel = 1;
            const minZoom = 0.5;
            const maxZoom = 5;
            
            // 测试触摸事件是否正常工作
            canvasEl.addEventListener('touchstart', function(e) {
                console.log('画布触摸测试 - touchstart触发，触摸点数:', e.touches.length);
            }, false);
            
            canvasEl.addEventListener('touchmove', function(e) {
                if (e.touches.length === 2) {
                    console.log('画布触摸测试 - 检测到双指触摸移动');
                }
            }, false);

            const elements = {
                shapeType: document.getElementById('shapeType'),
                // 移除旧的通用输入框
                // 矩形参数
                rectWidth: document.getElementById('rectWidth'),
                rectHeight: document.getElementById('rectHeight'),
                // 圆形参数
                circleDiameter: document.getElementById('circleDiameter'),
                circleRadius: document.getElementById('circleRadius'),
                // 三角形参数
                triangleBase: document.getElementById('triangleBase'),
                triangleHeight: document.getElementById('triangleHeight'),
                // 线段参数
                lineLength: document.getElementById('lineLength'),
                // 参数容器
                rectParams: document.getElementById('rectParams'),
                circleParams: document.getElementById('circleParams'),
                triangleParams: document.getElementById('triangleParams'),
                lineParams: document.getElementById('lineParams'),
                
                addShapeBtn: document.getElementById('addShapeBtn'),
                deleteBtn: document.getElementById('deleteBtn'),
                imageUpload: document.getElementById('imageUpload'),
                fontFamily: document.getElementById('fontFamily'),
                addText: document.getElementById('addText'),
                textContent: document.getElementById('textContent'),
                saveBtn: document.getElementById('saveBtn'),
                tipContainer: document.getElementById('tip-container'),
                zoomIn: document.getElementById('zoomIn'),
                zoomOut: document.getElementById('zoomOut'),
                zoomReset: document.getElementById('zoomReset'),
                zoomFit: document.getElementById('zoomFit'),
                zoomIndicator: document.getElementById('zoomIndicator'),
                enlargeObject: document.getElementById('enlargeObject'),
                shrinkObject: document.getElementById('shrinkObject'),
                toggleToolbar: document.getElementById('toggleToolbar'),
                toolbarContainer: document.getElementById('toolbarContainer')
            };

            // 全局设置以跟踪当前使用模式
            const appState = {
                toolbarVisible: false // 默认隐藏工具栏
            };
            
            // 初始化检查 - 确保关键元素存在
            console.log('初始化检查:');
            console.log('- 工具栏切换按钮:', elements.toggleToolbar ? '存在' : '不存在');
            console.log('- 工具栏容器:', elements.toolbarContainer ? '存在' : '不存在');
            
            // 确保工具栏容器正确设置
            if (elements.toolbarContainer) {
                console.log('工具栏容器ID:', elements.toolbarContainer.id);
                console.log('工具栏容器初始display:', window.getComputedStyle(elements.toolbarContainer).display);
            }

            // 工具栏切换系统 - 加强版
            const toolbarSystem = {
                init() {
                    // 确保元素引用是正确的
                    this.toggleBtn = document.getElementById('toggleToolbar');
                    this.toolbarContainer = document.getElementById('toolbarContainer');
                    
                    if (!this.toggleBtn || !this.toolbarContainer) {
                        console.error('工具栏元素未找到!', 
                                     '按钮:', this.toggleBtn ? '存在' : '不存在', 
                                     '容器:', this.toolbarContainer ? '存在' : '不存在');
                        return;
                    }
                    
                    console.log('工具栏初始化成功');
                    
                    // 直接绑定事件到DOM元素
                    this.toggleBtn.onclick = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        this.toggle();
                        return false;
                    };
                    
                    // 额外绑定触摸事件
                    this.toggleBtn.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        this.toggle();
                    }, {passive: false});
                    
                    // 确保按钮可见
                    this.toggleBtn.style.display = 'flex';
                },
                
                toggle() {
                    console.log('工具栏切换请求');
                    appState.toolbarVisible = !appState.toolbarVisible;
                    elements.toolbarContainer.style.display = appState.toolbarVisible ? 'block' : 'none';
                    elements.toggleToolbar.textContent = appState.toolbarVisible ? '关闭' : '工具';
                    
                    console.log('工具栏状态:', appState.toolbarVisible ? '显示' : '隐藏');
                    
                    // 如果显示工具栏，调整画布位置给工具栏留出空间
                    if (appState.toolbarVisible) {
                        // 获取工具栏高度
                        const toolbarHeight = elements.toolbarContainer.offsetHeight;
                        document.getElementById('canvas-wrapper').style.paddingTop = `${toolbarHeight}px`;
                        console.log('工具栏高度:', toolbarHeight, 'px');
                    } else {
                        document.getElementById('canvas-wrapper').style.paddingTop = '0';
                    }
                    
                    // 强制刷新DOM
                    setTimeout(() => {
                        if (appState.toolbarVisible) {
                            // 确保工具栏可见
                            const actualDisplay = window.getComputedStyle(elements.toolbarContainer).display;
                            console.log('实际显示状态:', actualDisplay);
                            if (actualDisplay === 'none') {
                                console.log('强制显示工具栏');
                                elements.toolbarContainer.style.display = 'block';
                                elements.toolbarContainer.style.visibility = 'visible';
                                elements.toolbarContainer.style.opacity = '1';
                            }
                        }
                    }, 50);
                }
            };

            // 图形参数切换系统
            const shapeParamsSystem = {
                init() {
                    // 监听图形类型切换
                    elements.shapeType.addEventListener('change', () => {
                        this.switchParams(elements.shapeType.value);
                    });
                    
                    // 监听圆形直径输入，自动计算半径
                    elements.circleDiameter.addEventListener('input', () => {
                        const diameter = parseFloat(elements.circleDiameter.value) || 0;
                        elements.circleRadius.value = Math.round(diameter / 2);
                    });
                },
                
                switchParams(shapeType) {
                    // 隐藏所有参数容器
                    elements.rectParams.style.display = 'none';
                    elements.circleParams.style.display = 'none';
                    elements.triangleParams.style.display = 'none';
                    elements.lineParams.style.display = 'none';
                    
                    // 显示对应的参数容器
                    switch(shapeType) {
                        case 'rect':
                            elements.rectParams.style.display = 'flex';
                            break;
                        case 'circle':
                            elements.circleParams.style.display = 'flex';
                            // 更新半径显示
                            const diameter = parseFloat(elements.circleDiameter.value) || 0;
                            elements.circleRadius.value = Math.round(diameter / 2);
                            break;
                        case 'triangle':
                            elements.triangleParams.style.display = 'flex';
                            break;
                        case 'line':
                            elements.lineParams.style.display = 'flex';
                            break;
                    }
                }
            };

            // 缩放系统 - 添加自动适应内容的功能
            const zoomSystem = {
                // 添加防抖机制，避免多个缩放操作同时进行
                isZooming: false,
                zoomDebounceTimeout: null,
                
                // 安全的缩放包装器
                safeZoom(zoomOperation) {
                    if (this.isZooming) {
                        console.log('缩放操作正在进行中，跳过');
                        return;
                    }
                    
                    this.isZooming = true;
                    
                    // 清除之前的防抖定时器
                    if (this.zoomDebounceTimeout) {
                        clearTimeout(this.zoomDebounceTimeout);
                    }
                    
                    try {
                        zoomOperation();
                    } catch (error) {
                        console.error('缩放操作出错:', error);
                    } finally {
                        // 防抖延迟后才允许下一次缩放
                        this.zoomDebounceTimeout = setTimeout(() => {
                            this.isZooming = false;
                        }, 100);
                    }
                },
                
                zoomIn() {
                    this.safeZoom(() => {
                    if (zoomLevel < maxZoom) {
                        zoomLevel = Math.min(zoomLevel * 1.2, maxZoom);
                        this.applyZoom();
                            
                            // 显示缩放控制器
                            document.querySelector('.zoom-controls').style.display = 'flex';
                            document.getElementById('zoomIndicator').style.display = 'block';
                            
                            // 3秒后隐藏
                            setTimeout(() => {
                                document.querySelector('.zoom-controls').style.display = 'none';
                                document.getElementById('zoomIndicator').style.display = 'none';
                            }, 3000);
                        }
                    });
                },
                zoomOut() {
                    this.safeZoom(() => {
                    if (zoomLevel > minZoom) {
                        zoomLevel = Math.max(zoomLevel / 1.2, minZoom);
                        this.applyZoom();
                            
                            // 显示缩放控制器
                            document.querySelector('.zoom-controls').style.display = 'flex';
                            document.getElementById('zoomIndicator').style.display = 'block';
                            
                            // 3秒后隐藏
                            setTimeout(() => {
                                document.querySelector('.zoom-controls').style.display = 'none';
                                document.getElementById('zoomIndicator').style.display = 'none';
                            }, 3000);
                        }
                    });
                },
                resetZoom() {
                    this.safeZoom(() => {
                    zoomLevel = 1;
                        canvas.setViewportTransform([1, 0, 0, 1, 0, 0]); // 重置所有变换
                    this.applyZoom();
                        
                        // 重置保存的变换状态
                        viewportTransform = [1, 0, 0, 1, 0, 0];
                        mouseViewportTransform = [1, 0, 0, 1, 0, 0];
                        
                        tipSystem.show('已重置视图位置和缩放');
                    });
                },
                // 根据内容自动调整缩放
                zoomToFitContent() {
                    this.safeZoom(() => {
                    const objects = canvas.getObjects();
                    if (objects.length === 0) return;
                    
                    // 获取所有对象的包围盒
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    
                    objects.forEach(obj => {
                        if (!obj.visible) return;
                        
                        const objBounds = obj.getBoundingRect();
                        minX = Math.min(minX, objBounds.left);
                        minY = Math.min(minY, objBounds.top);
                        maxX = Math.max(maxX, objBounds.left + objBounds.width);
                        maxY = Math.max(maxY, objBounds.top + objBounds.height);
                    });
                    
                    // 计算内容的宽高
                    const contentWidth = maxX - minX;
                    const contentHeight = maxY - minY;
                    
                        // 获取窗口尺寸
                        const windowWidth = window.innerWidth;
                        const windowHeight = window.innerHeight;
                    
                    // 计算需要的缩放比例，给边缘留些空间
                        const padding = 50;
                        const widthRatio = (windowWidth - padding * 2) / contentWidth;
                        const heightRatio = (windowHeight - padding * 2) / contentHeight;
                    
                    // 取较小的比例，确保内容完全可见
                        let newZoomLevel = Math.min(widthRatio, heightRatio);
                    
                    // 设置合理的缩放范围
                    newZoomLevel = Math.min(Math.max(newZoomLevel, minZoom), maxZoom);
                    
                        // 应用新的缩放
                        zoomLevel = newZoomLevel;
                        canvas.setZoom(zoomLevel);
                        
                        // 重置视口变换
                        canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
                        
                        // 设置画布尺寸
                        canvas.setDimensions({
                            width: windowWidth,
                            height: windowHeight
                        });
                        
                        // 计算内容中心点
                        const centerX = (minX + maxX) / 2;
                        const centerY = (minY + maxY) / 2;
                        
                        // 计算需要的偏移量，使内容居中
                        const vpt = canvas.viewportTransform;
                        vpt[0] = zoomLevel;
                        vpt[3] = zoomLevel;
                        vpt[4] = windowWidth / 2 - centerX * zoomLevel;
                        vpt[5] = windowHeight / 2 - centerY * zoomLevel;
                        
                        canvas.setViewportTransform(vpt);
                        canvas.renderAll();
                        
                        // 更新UI
                        document.getElementById('zoomIndicator').textContent = `缩放: ${Math.round(zoomLevel * 100)}%`;
                        document.getElementById('zoomIndicator').style.display = 'block';
                        document.querySelector('.zoom-controls').style.display = 'flex';
                        
                        tipSystem.show(`已调整视图以显示所有内容 (${Math.round(zoomLevel * 100)}%)`);
                        
                        // 3秒后隐藏控制器
                        setTimeout(() => {
                            document.querySelector('.zoom-controls').style.display = 'none';
                            document.getElementById('zoomIndicator').style.display = 'none';
                        }, 3000);
                    });
                },
                // 统一应用缩放的方法
                applyZoom() {
                    // 保存当前视口变换
                    const currentVpt = [...canvas.viewportTransform];
                    
                    // 获取当前窗口尺寸
                    const windowWidth = window.innerWidth;
                    const windowHeight = window.innerHeight;
                    
                    // 设置新的缩放级别
                    canvas.setZoom(zoomLevel);
                    
                    // 设置画布尺寸为窗口尺寸（不使用缩放倍数）
                    canvas.setDimensions({
                        width: windowWidth,
                        height: windowHeight
                    });
                    
                    // 保持当前的平移位置，只更新缩放部分
                    const newVpt = [...currentVpt];
                    newVpt[0] = zoomLevel; // x轴缩放
                    newVpt[3] = zoomLevel; // y轴缩放
                    
                    canvas.setViewportTransform(newVpt);
                    canvas.renderAll();
                    
                    // 更新缩放指示器
                    document.getElementById('zoomIndicator').textContent = `缩放: ${Math.round(zoomLevel * 100)}%`;
                    
                    // 显示临时提示
                    tipSystem.show(`缩放: ${Math.round(zoomLevel * 100)}%`);
                },
                // 缩放选中对象 - 增强版
                enlargeSelectedObject() {
                    const activeObj = canvas.getActiveObject();
                    if (!activeObj) {
                        tipSystem.show('请先选择一个对象');
                        return;
                    }
                    
                    // 获取当前画布尺寸
                    const canvasWidth = canvas.width / zoomLevel;
                    const canvasHeight = canvas.height / zoomLevel;
                    
                    // 计算新的缩放因子，每次放大20%
                    const newScaleX = activeObj.scaleX * 1.2;
                    const newScaleY = activeObj.scaleY * 1.2;
                    
                    // 计算新尺寸
                    const newWidth = activeObj.width * newScaleX;
                    const newHeight = activeObj.height * newScaleY;
                    
                    // 放宽最大尺寸限制，允许对象放大到比画布更大
                    const maxSizeMultiplier = 2.0; // 允许放大到画布的2倍
                    if (newWidth > canvasWidth * maxSizeMultiplier || newHeight > canvasHeight * maxSizeMultiplier) {
                        tipSystem.show('对象已达到最大尺寸');
                        return;
                    }
                    
                    // 保存当前位置，防止位置跳动
                    const currentLeft = activeObj.left;
                    const currentTop = activeObj.top;
                    
                    // 合并所有属性更新，减少重渲染
                    const updateProps = {
                        scaleX: newScaleX,
                        scaleY: newScaleY,
                        left: currentLeft,  // 保持原位置
                        top: currentTop     // 保持原位置
                    };
                    
                    // 如果是图形对象，保持锁定状态
                    if (['rect', 'triangle', 'circle', 'line'].includes(activeObj.type)) {
                        updateProps.lockScalingX = true;
                        updateProps.lockScalingY = true;
                        updateProps.hasControls = false;
                    }
                    
                    // 一次性应用所有更新
                    activeObj.set(updateProps);
                    activeObj.setCoords(); // 更新坐标缓存
                    
                    // 更新UI控件
                    if (['rect', 'triangle', 'circle', 'line'].includes(activeObj.type)) {
                        // 计算新的尺寸值
                        if (activeObj.type === 'circle') {
                            const effectiveDiameter = Math.round(activeObj.radius * activeObj.scaleX * 2 / (MM_TO_PIXEL * SCALE_FACTOR));
                            elements.circleDiameter.value = effectiveDiameter;
                            elements.circleRadius.value = Math.round(effectiveDiameter / 2);
                        } else if (activeObj.type === 'rect') {
                            elements.rectWidth.value = Math.round(activeObj.width * activeObj.scaleX / (MM_TO_PIXEL * SCALE_FACTOR));
                            elements.rectHeight.value = Math.round(activeObj.height * activeObj.scaleY / (MM_TO_PIXEL * SCALE_FACTOR));
                        } else if (activeObj.type === 'triangle') {
                            elements.triangleBase.value = Math.round(activeObj.width * activeObj.scaleX / (MM_TO_PIXEL * SCALE_FACTOR));
                            elements.triangleHeight.value = Math.round(activeObj.height * activeObj.scaleY / (MM_TO_PIXEL * SCALE_FACTOR));
                        } else if (activeObj.type === 'line') {
                            elements.lineLength.value = Math.round(activeObj.width * activeObj.scaleX / (MM_TO_PIXEL * SCALE_FACTOR));
                        }
                    } else if (activeObj.type === 'text') {
                        const newFontSize = activeObj.fontSize * 1.2;
                        activeObj.set({ fontSize: newFontSize });
                    }
                    
                    canvas.requestRenderAll();
                    tipSystem.show('已放大选中对象');
                    
                    // 不再调用 enforceObjectBoundaries，避免位置跳动
                },
                shrinkSelectedObject() {
                    const activeObj = canvas.getActiveObject();
                    if (!activeObj) {
                        tipSystem.show('请先选择一个对象');
                        return;
                    }
                    
                    // 计算新的缩放因子，每次缩小20%
                    const newScaleX = activeObj.scaleX * 0.8;
                    const newScaleY = activeObj.scaleY * 0.8;
                    
                    // 计算新尺寸
                    const newWidth = activeObj.width * newScaleX;
                    const newHeight = activeObj.height * newScaleY;
                    
                    // 较小的最小尺寸，允许对象缩小得更小
                    const minSize = 3 * MM_TO_PIXEL * SCALE_FACTOR;
                    if (newWidth < minSize || newHeight < minSize) {
                        tipSystem.show('对象已达到最小尺寸');
                        return;
                    }
                    
                    // 保存当前位置，防止位置跳动
                    const currentLeft = activeObj.left;
                    const currentTop = activeObj.top;
                    
                    // 合并所有属性更新，减少重渲染
                    const updateProps = {
                        scaleX: newScaleX,
                        scaleY: newScaleY,
                        left: currentLeft,  // 保持原位置
                        top: currentTop     // 保持原位置
                    };
                    
                    // 如果是图形对象，保持锁定状态
                    if (['rect', 'triangle', 'circle', 'line'].includes(activeObj.type)) {
                        updateProps.lockScalingX = true;
                        updateProps.lockScalingY = true;
                        updateProps.hasControls = false;
                    }
                    
                    // 一次性应用所有更新
                    activeObj.set(updateProps);
                    activeObj.setCoords(); // 更新坐标缓存
                    
                    // 更新UI控件
                    if (['rect', 'triangle', 'circle', 'line'].includes(activeObj.type)) {
                        // 计算新的尺寸值
                        if (activeObj.type === 'circle') {
                            const effectiveDiameter = Math.round(activeObj.radius * activeObj.scaleX * 2 / (MM_TO_PIXEL * SCALE_FACTOR));
                            elements.circleDiameter.value = effectiveDiameter;
                            elements.circleRadius.value = Math.round(effectiveDiameter / 2);
                        } else if (activeObj.type === 'rect') {
                            elements.rectWidth.value = Math.round(activeObj.width * activeObj.scaleX / (MM_TO_PIXEL * SCALE_FACTOR));
                            elements.rectHeight.value = Math.round(activeObj.height * activeObj.scaleY / (MM_TO_PIXEL * SCALE_FACTOR));
                        } else if (activeObj.type === 'triangle') {
                            elements.triangleBase.value = Math.round(activeObj.width * activeObj.scaleX / (MM_TO_PIXEL * SCALE_FACTOR));
                            elements.triangleHeight.value = Math.round(activeObj.height * activeObj.scaleY / (MM_TO_PIXEL * SCALE_FACTOR));
                        } else if (activeObj.type === 'line') {
                            elements.lineLength.value = Math.round(activeObj.width * activeObj.scaleX / (MM_TO_PIXEL * SCALE_FACTOR));
                        }
                    } else if (activeObj.type === 'text') {
                        const newFontSize = activeObj.fontSize * 0.8;
                        activeObj.set({ 
                            fontSize: Math.max(8, newFontSize) // 字体最小8px
                        });
                    }
                    
                    canvas.requestRenderAll();
                    tipSystem.show('已缩小选中对象');
                    
                    // 不再调用 enforceObjectBoundaries，避免位置跳动
                }
            };

            // 提示系统 - 优化版
            const tipSystem = {
                lastMessage: '',
                lastShowTime: 0,
                debounceTime: 300, // 提示消息防抖时间
                
                show(message, duration = 2000) {
                    // 防抖处理，减少频繁更新DOM
                    const now = Date.now();
                    if (message === this.lastMessage && now - this.lastShowTime < this.debounceTime) {
                        return; // 短时间内重复消息不显示
                    }
                    
                    this.lastMessage = message;
                    this.lastShowTime = now;
                    
                    // 使用requestAnimationFrame减少布局抖动
                    requestAnimationFrame(() => {
                        elements.tipContainer.textContent = message;
                        elements.tipContainer.style.opacity = '1';
                        
                        // 自动隐藏提示
                        if (this.hideTimeout) clearTimeout(this.hideTimeout);
                        this.hideTimeout = setTimeout(() => {
                            elements.tipContainer.style.opacity = '0';
                        }, duration);
                    });
                },
                hideTimeout: null
            };

            // 尺寸同步系统
            const sizeSync = {
                updateShape() {
                    const activeObj = canvas.getActiveObject();
                    if (!activeObj) return;
                    
                    let sizeChanged = false;
                    const originalWidth = activeObj.width * activeObj.scaleX;
                    const originalHeight = activeObj.height * activeObj.scaleY;

                    // 图形尺寸更新逻辑
                    if (activeObj.type === 'rect') {
                        const newWidth = parseFloat(elements.rectWidth.value) * MM_TO_PIXEL * SCALE_FACTOR;
                        const newHeight = parseFloat(elements.rectHeight.value) * MM_TO_PIXEL * SCALE_FACTOR;
                        activeObj.set({ width: newWidth, height: newHeight });
                        sizeChanged = true;
                    } else if (activeObj.type === 'triangle') {
                        const newWidth = parseFloat(elements.triangleBase.value) * MM_TO_PIXEL * SCALE_FACTOR;
                        const newHeight = parseFloat(elements.triangleHeight.value) * MM_TO_PIXEL * SCALE_FACTOR;
                        activeObj.set({ width: newWidth, height: newHeight });
                        sizeChanged = true;
                    } else if (activeObj.type === 'line') {
                        const newWidth = parseFloat(elements.lineLength.value) * MM_TO_PIXEL * SCALE_FACTOR;
                        activeObj.set({ 
                            x2: newWidth,
                            width: newWidth 
                        });
                        sizeChanged = true;
                    } else if (activeObj.type === 'circle') {
                        const newDiameter = parseFloat(elements.circleDiameter.value) * MM_TO_PIXEL * SCALE_FACTOR;
                        activeObj.set({ radius: newDiameter / 2 });
                        sizeChanged = true;
                    } else if (activeObj.type === 'text') {
                        const oldSize = activeObj.fontSize;
                        
                        activeObj.set({
                            fontFamily: elements.fontFamily.value,
                            text: elements.textContent.value || '示例文字'
                        });
                        
                        sizeChanged = false;
                    }
                    
                    canvas.requestRenderAll();
                    
                    // 检查尺寸变化是否显著，如果是，则自动调整视图
                    if (sizeChanged) {
                        const newWidth = activeObj.width * activeObj.scaleX;
                        const newHeight = activeObj.height * activeObj.scaleY;
                        
                        // 如果尺寸变大了，且对象变得很大，自动调整视图以适应对象
                        if ((newWidth > originalWidth * 1.5 || newHeight > originalHeight * 1.5) &&
                            (newWidth > canvas.width * 0.5 / zoomLevel || newHeight > canvas.height * 0.5 / zoomLevel)) {
                            setTimeout(() => zoomSystem.zoomToFitContent(), 50);
                        }
                    }
                },
                // 从对象同步到控件
                syncFromObject(obj) {
                    if (!obj) return;
                    
                    // 先切换到对应的参数面板
                    if (['rect', 'triangle', 'circle', 'line'].includes(obj.type)) {
                        elements.shapeType.value = obj.type;
                        shapeParamsSystem.switchParams(obj.type);
                    }
                    
                    if (obj.type === 'rect') {
                        elements.rectWidth.value = Math.round(obj.width / (MM_TO_PIXEL * SCALE_FACTOR));
                        elements.rectHeight.value = Math.round(obj.height / (MM_TO_PIXEL * SCALE_FACTOR));
                    } else if (obj.type === 'triangle') {
                        elements.triangleBase.value = Math.round(obj.width / (MM_TO_PIXEL * SCALE_FACTOR));
                        elements.triangleHeight.value = Math.round(obj.height / (MM_TO_PIXEL * SCALE_FACTOR));
                    } else if (obj.type === 'line') {
                        const length = Math.abs(obj.x2 - obj.x1);
                        elements.lineLength.value = Math.round(length / (MM_TO_PIXEL * SCALE_FACTOR));
                    } else if (obj.type === 'circle') {
                        const diameter = Math.round(obj.radius * 2 / (MM_TO_PIXEL * SCALE_FACTOR));
                        elements.circleDiameter.value = diameter;
                        elements.circleRadius.value = Math.round(diameter / 2);
                    } else if (obj.type === 'text') {
                        elements.fontFamily.value = obj.fontFamily;
                        elements.textContent.value = obj.text;
                    }
                }
            };

            // 图形创建系统
            const shapeSystem = {
                createShape() {
                    const type = elements.shapeType.value;
                    let width, height;
                    const strokeWidth = 2; // 设置默认边框宽度为2像素

                    // 根据不同图形类型获取参数
                    switch(type) {
                        case 'rect':
                            width = parseFloat(elements.rectWidth.value) * MM_TO_PIXEL * SCALE_FACTOR;
                            height = parseFloat(elements.rectHeight.value) * MM_TO_PIXEL * SCALE_FACTOR;
                            break;
                        case 'circle':
                            const diameter = parseFloat(elements.circleDiameter.value) * MM_TO_PIXEL * SCALE_FACTOR;
                            width = diameter;
                            height = diameter;
                            break;
                        case 'triangle':
                            width = parseFloat(elements.triangleBase.value) * MM_TO_PIXEL * SCALE_FACTOR;
                            height = parseFloat(elements.triangleHeight.value) * MM_TO_PIXEL * SCALE_FACTOR;
                            break;
                        case 'line':
                            width = parseFloat(elements.lineLength.value) * MM_TO_PIXEL * SCALE_FACTOR;
                            height = 0; // 线段高度为0
                            break;
                    }

                    // 获取当前画布尺寸
                    const canvasWidth = canvas.width / zoomLevel;
                    const canvasHeight = canvas.height / zoomLevel;

                    // 不再限制尺寸，允许创建大于画布的图形
                    const safeWidth = width;
                    const safeHeight = height;

                    const common = {
                        fill: 'transparent',
                        stroke: '#333',
                        strokeWidth: strokeWidth,
                        strokeUniform: true,
                        hasRotatingPoint: false, // 禁用旋转
                        left: canvasWidth / 2,
                        top: canvasHeight / 2,
                        lockScalingX: true, // 禁止水平缩放
                        lockScalingY: true, // 禁止垂直缩放
                        hasControls: false, // 隐藏所有控制点
                        hasBorders: true, // 保留边框
                        selectable: true, // 保持可选择以便移动
                        visible: true, // 确保可见
                        opacity: 1, // 确保不透明
                        evented: true // 确保可交互
                    };

                    const shape = type === 'circle' 
                        ? new fabric.Circle({ radius: safeWidth/2, ...common })
                        : type === 'triangle'
                        ? new fabric.Triangle({ width: safeWidth, height: safeHeight, ...common })
                        : type === 'line'
                        ? new fabric.Line([0,0,safeWidth,0], { ...common })
                        : new fabric.Rect({ width: safeWidth, height: safeHeight, ...common });

                    // 确保对象被正确添加到画布
                    canvas.add(shape);
                    canvas.setActiveObject(shape);
                    
                    // 强制重渲染确保显示
                    canvas.renderAll();
                    
                    // 在控制台输出检测信息
                    console.log('添加图形:', {
                        type: shape.type,
                        visible: shape.visible,
                        left: shape.left,
                        top: shape.top,
                        width: shape.width,
                        height: shape.height,
                        inputWidth: type === 'rect' ? elements.rectWidth.value : 0,
                        inputHeight: type === 'rect' ? elements.rectHeight.value : 0
                    });
                    
                    tipSystem.show(`已添加${elements.shapeType.options[elements.shapeType.selectedIndex].text}（${type === 'rect' ? elements.rectWidth.value + 'x' + elements.rectHeight.value + 'mm' : ''}），可拖动调整位置`);
                    
                    // 延迟执行视图调整，确保对象完全渲染
                    setTimeout(() => {
                        // 强制刷新对象坐标
                        shape.setCoords();
                        canvas.renderAll();
                        
                        // 获取对象的实际边界
                        const objBounds = shape.getBoundingRect();
                        const objWidth = objBounds.width;
                        const objHeight = objBounds.height;
                        
                        console.log('图形实际尺寸:', objWidth, 'x', objHeight, 'px');
                        
                        // 获取窗口尺寸
                        const windowWidth = window.innerWidth;
                        const windowHeight = window.innerHeight;
                        
                        // 检查图形是否超出当前视图
                        const currentCanvasWidth = canvas.width / zoomLevel;
                        const currentCanvasHeight = canvas.height / zoomLevel;
                        
                        // 如果图形很大或超出视图，自动调整
                        if (objWidth > currentCanvasWidth * 0.8 || objHeight > currentCanvasHeight * 0.8) {
                            // 使用安全的缩放方式
                            zoomSystem.safeZoom(() => {
                                // 计算需要的缩放比例
                                const padding = 80; // 边距
                                const widthRatio = (windowWidth - padding * 2) / objWidth;
                                const heightRatio = (windowHeight - padding * 2) / objHeight;
                                
                                // 使用较小的比例确保图形完全可见
                                let targetZoom = Math.min(widthRatio, heightRatio);
                                targetZoom = Math.max(targetZoom, minZoom);
                                targetZoom = Math.min(targetZoom, maxZoom);
                                
                                console.log('自动调整缩放比例:', zoomLevel, '->', targetZoom);
                                
                                // 使用稳定的缩放方式
                                zoomLevel = targetZoom;
                                zoomSystem.applyZoom();
                                
                                // 将图形移到视图中心
                                const centerX = windowWidth / 2;
                                const centerY = windowHeight / 2;
                                shape.set({
                                    left: centerX / zoomLevel,
                                    top: centerY / zoomLevel
                                });
                                shape.setCoords();
                                
                                // 强制渲染
                                canvas.renderAll();
                                
                                // 更新UI显示
                                document.getElementById('zoomIndicator').textContent = `缩放: ${Math.round(zoomLevel * 100)}%`;
                                document.getElementById('zoomIndicator').style.display = 'block';
                                document.querySelector('.zoom-controls').style.display = 'flex';
                                
                                tipSystem.show(`已自动缩放到 ${Math.round(zoomLevel * 100)}% 以显示大尺寸图形`);
                                
                                // 3秒后隐藏控制器
                                setTimeout(() => {
                                    document.querySelector('.zoom-controls').style.display = 'none';
                                    document.getElementById('zoomIndicator').style.display = 'none';
                                }, 3000);
                            });
                        }
                    }, 300); // 增加延迟时间确保渲染完成
                }
            };

            // 文字创建系统
            const textSystem = {
                addText() {
                    // 获取当前画布尺寸
                    const canvasWidth = canvas.width / zoomLevel;
                    const canvasHeight = canvas.height / zoomLevel;
                    
                    const text = new fabric.Text(elements.textContent.value || '示例文字', {
                        left: canvasWidth / 2,
                        top: canvasHeight / 2,
                        fontFamily: elements.fontFamily.value,
                        fontSize: 24, // 默认字号设为24
                        fill: '#333', // 默认深灰色，在白色背景上可见
                        editable: true,
                        lockScalingX: false, // 允许水平缩放
                        lockScalingY: false, // 允许垂直缩放
                        hasControls: true, // 显示控制点
                        hasBorders: true, // 保留边框
                        cornerSize: 10, // 设置控制点大小
                        cornerColor: '#3b82f6', // 控制点颜色
                        cornerStyle: 'circle', // 圆形控制点
                        transparentCorners: false, // 实心控制点
                        selectable: true, // 保持可选择以便移动
                        visible: true, // 确保可见
                        opacity: 1, // 确保不透明
                        evented: true, // 确保可交互
                        lockRotation: true, // 锁定旋转
                        lockSkewingX: true, // 锁定X方向歪斜
                        lockSkewingY: true // 锁定Y方向歪斜
                    });

                    // 确保文字对象正确添加到画布
                    canvas.add(text);
                    canvas.setActiveObject(text);
                    enforceObjectBoundaries(text);
                    
                    // 强制重渲染确保显示
                    canvas.renderAll();
                    
                    // 在控制台输出检测信息
                    console.log('添加文字:', {
                        content: text.text,
                        visible: text.visible,
                        left: text.left,
                        top: text.top,
                        fontSize: text.fontSize
                    });
                    
                    tipSystem.show('已添加文字，可拖动调整位置和大小');
                    
                    // 延迟渲染确保显示
                    setTimeout(() => canvas.renderAll(), 100);
                },
                // 现在通过双击文本直接编辑，不需要按钮
                editText() {
                    const activeObj = canvas.getActiveObject();
                    if (activeObj && activeObj.type === 'text') {
                        activeObj.enterEditing();
                        tipSystem.show('可以直接编辑文字内容');
                    } else {
                        tipSystem.show('请先选择文字对象');
                    }
                }
            };

            // 图片上传系统 - 改进自动检测
            const imageSystem = {
                // 改进二维码检测算法
                detectQRCode(imgElement) {
                    try {
                        // 创建临时Canvas用于分析图片
                        const tempCanvas = document.createElement('canvas');
                        const tempCtx = tempCanvas.getContext('2d');
                        
                        // 调整为较小尺寸以提高性能
                        const size = 300; // 增加分析尺寸以提高准确性
                        tempCanvas.width = size;
                        tempCanvas.height = size;
                        
                        // 绘制图像
                        tempCtx.drawImage(imgElement, 0, 0, size, size);
                        
                        // 获取图像数据
                        const imageData = tempCtx.getImageData(0, 0, size, size);
                        const data = imageData.data;
                        
                        // 计算黑白像素的特征
                        let blackPixels = 0;
                        let whitePixels = 0;
                        let grayPixels = 0;
                        let colorPixels = 0;
                        
                        // 检测图像边缘特征（二维码通常有明显的边缘）
                        let edgeCount = 0;
                        let pixelChanges = 0;
                        
                        // 分析每一行，检测颜色变化（二维码有很多黑白交替）
                        for (let y = 1; y < size; y++) {
                            for (let x = 1; x < size; x++) {
                                const idx = (y * size + x) * 4;
                                const prevIdxX = (y * size + (x-1)) * 4;
                                const prevIdxY = ((y-1) * size + x) * 4;
                                
                                // 检测水平和垂直方向的颜色变化
                                if (Math.abs(data[idx] - data[prevIdxX]) > 50) {
                                    pixelChanges++;
                                }
                                if (Math.abs(data[idx] - data[prevIdxY]) > 50) {
                                    pixelChanges++;
                                }
                                
                                const r = data[idx];
                                const g = data[idx + 1];
                                const b = data[idx + 2];
                                
                                // 检查是否为黑白或灰色像素
                                const isGray = Math.abs(r - g) < 20 && Math.abs(r - b) < 20 && Math.abs(g - b) < 20;
                                
                                if (isGray) {
                                    if (r < 60) {
                                        blackPixels++;
                                    } else if (r > 200) {
                                        whitePixels++;
                                    } else {
                                        grayPixels++;
                                    }
                                } else {
                                    colorPixels++;
                                }
                            }
                        }
                        
                        const totalPixels = size * size;
                        const blackWhiteRatio = (blackPixels + whitePixels) / totalPixels;
                        const colorRatio = colorPixels / totalPixels;
                        const pixelChangeRatio = pixelChanges / (totalPixels * 2); // 考虑了水平和垂直方向
                        
                        // 改进的二维码特征检测:
                        // 1. 大量黑白像素
                        // 2. 很少的彩色像素
                        // 3. 频繁的像素变化（黑白交替）
                        // 4. 放宽条件，优先识别为二维码
                        const isQRCode = (
                            (blackWhiteRatio > 0.7 && colorRatio < 0.2) || // 常规二维码
                            (pixelChangeRatio > 0.15 && blackPixels > totalPixels * 0.05) || // 基于边缘特征
                            (blackPixels > totalPixels * 0.1 && blackPixels < totalPixels * 0.7 && 
                             whitePixels > totalPixels * 0.1) // 基于黑白比例
                        );
                        
                        // 添加判断为二维码的倾向 - 宁可错误地将普通图片识别为二维码，也不要错过二维码
                        const possiblyQRCode = 
                            (blackPixels > totalPixels * 0.05 && pixelChangeRatio > 0.12) ||
                            (blackWhiteRatio > 0.6 && colorRatio < 0.3);
                        
                        console.log('图片分析结果:', {
                            blackWhiteRatio, colorRatio, pixelChangeRatio,
                            blackPixels: blackPixels/totalPixels, 
                            whitePixels: whitePixels/totalPixels,
                            isQRCode, possiblyQRCode
                        });
                        
                        // 分析结果 - 优先判断为二维码
                        return {
                            isQRCode: isQRCode || possiblyQRCode,
                            blackWhiteRatio: blackWhiteRatio,
                            colorRatio: colorRatio,
                            confidence: isQRCode ? 'high' : (possiblyQRCode ? 'medium' : 'low')
                        };
                    } catch (e) {
                        console.error('图片分析出错:', e);
                        return { isQRCode: true }; // 出错时默认为二维码，避免丢失
                    }
                },
                
                uploadImage(e) {
                    if (e.target.files && e.target.files[0]) {
                        tipSystem.show('正在分析图片类型，请稍候...');
                        
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            // 创建临时图片元素用于分析
                            const tempImg = new Image();
                            tempImg.onload = () => {
                                // 检测图片类型
                                const analysisResult = this.detectQRCode(tempImg);
                                const isQRCode = analysisResult.isQRCode;
                                
                                // 根据检测结果设置图片类型
                                const imageType = isQRCode ? 'qrcode' : 'background';
                                
                                // 获取当前画布尺寸
                                const canvasWidth = canvas.width / zoomLevel;
                                const canvasHeight = canvas.height / zoomLevel;
                                
                                // 创建Fabric图像对象
                                fabric.Image.fromURL(event.target.result, function(img) {
                                    // 等比例缩放图片
                                    const maxSide = Math.min(canvasWidth, canvasHeight) * 0.7;
                                    let scale = 1;
                                    
                                    if (img.width > img.height && img.width > maxSide) {
                                        scale = maxSide / img.width;
                                    } else if (img.height > maxSide) {
                                        scale = maxSide / img.height;
                                    }
                                    
                                    img.scale(scale).set({
                                        left: canvasWidth / 2,
                                        top: canvasHeight / 2,
                                        selectable: true,
                                        evented: true,
                                        imageType: imageType, // 自动设置图片类型
                                        confidence: analysisResult.confidence, // 保存检测置信度
                                        lockScalingX: false, // 允许水平缩放
                                        lockScalingY: false, // 允许垂直缩放
                                        hasControls: true, // 显示控制点
                                        hasBorders: true, // 保留边框
                                        cornerSize: 10, // 设置控制点大小
                                        cornerColor: '#3b82f6', // 控制点颜色
                                        cornerStyle: 'circle', // 圆形控制点
                                        transparentCorners: false, // 实心控制点
                                        lockRotation: true, // 锁定旋转
                                        lockSkewingX: true, // 锁定X方向歪斜
                                        lockSkewingY: true, // 锁定Y方向歪斜
                                        lockUniScaling: false // 允许非等比缩放
                                    });
                                    
                                    // 确保图片正确添加到画布
                                    canvas.add(img);
                                    canvas.sendToBack(img);
                                    canvas.setActiveObject(img);
                                    enforceObjectBoundaries(img);
                                    
                                    // 强制重渲染确保显示
                                    canvas.renderAll();
                                    
                                    // 在控制台输出检测信息
                                    console.log('添加图片:', {
                                        imageType: imageType,
                                        visible: img.visible,
                                        left: img.left,
                                        top: img.top,
                                        width: img.width * img.scaleX,
                                        height: img.height * img.scaleY
                                    });
                                    
                                    if (isQRCode) {
                                        tipSystem.show('检测到二维码图片，导出时将保留并去除白色背景');
                                    } else {
                                        tipSystem.show('检测到背景图片，导出时将被移除');
                                    }
                                    
                                    // 等待图片加载后，自动调整视图以适应图片
                                    setTimeout(() => {
                                        canvas.renderAll(); // 再次确保渲染
                                        zoomSystem.zoomToFitContent();
                                    }, 100);
                                });
                            };
                            tempImg.src = event.target.result;
                        };
                        reader.readAsDataURL(e.target.files[0]);
                    }
                }
            };

            // 修改工具栏组标题
            document.querySelector('.toolbar-group:nth-child(3) .text-sm').textContent = '媒体与导出';

            // 修改保存按钮文字
            const saveBtn = document.getElementById('saveBtn');
            if (saveBtn) {
                saveBtn.textContent = '智能提取导出';
                saveBtn.className = 'bg-blue-600 text-white input-sm touch-target';
            }

            // 移除单独的二维码提取按钮
            if (document.getElementById('qrcodeExtractBtn')) {
                document.getElementById('qrcodeExtractBtn').remove();
            }

            // 整合的提取和导出系统
            const saveSystem = {
                // 提取并处理二维码图片，返回处理后的图片Promise
                async processQRCode(qrcodeImage) {
                    return new Promise((resolve) => {
                        try {
                            const imgElement = qrcodeImage.getElement();
                            
                            // 创建临时Canvas用于处理图像
                            const tempCanvas = document.createElement('canvas');
                            const tempCtx = tempCanvas.getContext('2d');
                            
                            // 设置Canvas尺寸
                            tempCanvas.width = imgElement.naturalWidth;
                            tempCanvas.height = imgElement.naturalHeight;
                            
                            // 绘制图像
                            tempCtx.drawImage(imgElement, 0, 0);
                            
                            // 获取图像数据
                            const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                            const data = imageData.data;
                            
                            // 处理图像数据，将白色背景变为透明
                            for (let i = 0; i < data.length; i += 4) {
                                const r = data[i];
                                const g = data[i + 1];
                                const b = data[i + 2];
                                
                                // 检测白色或接近白色的像素
                                if (r > 230 && g > 230 && b > 230) {
                                    data[i + 3] = 0; // 设为透明
                                }
                            }
                            
                            // 将处理后的数据放回Canvas
                            tempCtx.putImageData(imageData, 0, 0);
                            
                            // 转换为数据URL
                            const processedDataURL = tempCanvas.toDataURL('image/png');
                            
                            // 创建新的Fabric图像对象
                            fabric.Image.fromURL(processedDataURL, function(newImg) {
                                // 保持原图属性
                                newImg.set({
                                    left: qrcodeImage.left,
                                    top: qrcodeImage.top,
                                    scaleX: qrcodeImage.scaleX,
                                    scaleY: qrcodeImage.scaleY,
                                    angle: qrcodeImage.angle,
                                    imageType: 'qrcode_processed'
                                });
                                
                                resolve(newImg);
                            });
                        } catch (error) {
                            console.error('处理二维码时出错:', error);
                            // 出错时返回原图对象
                            resolve(qrcodeImage);
                        }
                    });
                },
                
                // 调试方法 - 显示当前画布对象信息
                debugCanvasObjects() {
                    const objects = canvas.getObjects();
                    console.log('画布上的对象:', objects.map(obj => ({
                        type: obj.type,
                        imageType: obj.imageType,
                        left: obj.left,
                        top: obj.top,
                        width: obj.width,
                        height: obj.height,
                        scaleX: obj.scaleX,
                        scaleY: obj.scaleY
                    })));
                    return objects;
                },
                
                // 显示导出预览和选项对话框
                showExportDialog(dataURL) {
                    // 创建对话框背景遮罩
                    const dialogOverlay = document.createElement('div');
                    dialogOverlay.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: rgba(0, 0, 0, 0.7);
                        z-index: 2000;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    `;
                    
                    // 创建对话框内容
                    const dialogContent = document.createElement('div');
                    dialogContent.style.cssText = `
                        background: white;
                        border-radius: 12px;
                        padding: 16px;
                        width: 85%;
                        max-width: 500px;
                        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
                        display: flex;
                        flex-direction: column;
                        gap: 12px;
                    `;
                    
                    // 创建标题
                    const title = document.createElement('h3');
                    title.textContent = '导出预览';
                    title.style.cssText = 'font-size: 18px; font-weight: bold; margin: 0; text-align: center;';
                    
                    // 创建图片预览
                    const preview = document.createElement('img');
                    preview.src = dataURL;
                    preview.style.cssText = 'max-width: 100%; max-height: 45vh; object-fit: contain; margin: 10px auto; border: 1px solid #eee;';
                    
                    // 创建说明文字
                    const helpText = document.createElement('p');
                    helpText.textContent = '选择保存方式:';
                    helpText.style.cssText = 'margin: 5px 0; font-size: 14px;';
                    
                    // 创建按钮容器
                    const buttonContainer = document.createElement('div');
                    buttonContainer.style.cssText = 'display: flex; flex-wrap: wrap; gap: 10px; justify-content: center;';
                    
                    // 创建下载按钮 - 主要选项
                    const downloadButton = document.createElement('button');
                    downloadButton.textContent = '下载PNG图片';
                    downloadButton.style.cssText = `
                        padding: 12px 16px;
                        background: #3b82f6;
                        color: white;
                        border: none;
                        border-radius: 8px;
                        font-size: 16px;
                        cursor: pointer;
                        flex: 1 0 auto;
                        min-width: 140px;
                    `;
                    
                    // 创建长按保存按钮
                    const longPressButton = document.createElement('button');
                    longPressButton.textContent = '长按图片保存';
                    longPressButton.style.cssText = `
                        padding: 12px 16px;
                        background: #10b981;
                        color: white;
                        border: none;
                        border-radius: 8px;
                        font-size: 16px;
                        cursor: pointer;
                        flex: 1 0 auto;
                        min-width: 140px;
                    `;
                    
                    // 创建另存为JPG按钮
                    const saveJpgButton = document.createElement('button');
                    saveJpgButton.textContent = '下载JPG图片';
                    saveJpgButton.style.cssText = `
                        padding: 12px 16px;
                        background: #f59e0b;
                        color: white;
                        border: none;
                        border-radius: 8px;
                        font-size: 16px;
                        cursor: pointer;
                        flex: 1 0 auto;
                        min-width: 140px;
                    `;
                    
                    // 创建取消按钮
                    const cancelButton = document.createElement('button');
                    cancelButton.textContent = '取消';
                    cancelButton.style.cssText = `
                        padding: 12px 16px;
                        background: #e5e7eb;
                        color: #111827;
                        border: none;
                        border-radius: 8px;
                        font-size: 16px;
                        cursor: pointer;
                        flex: 1 0 auto;
                        min-width: 100px;
                    `;
                    
                    // 添加按钮到容器
                    buttonContainer.appendChild(downloadButton);
                    buttonContainer.appendChild(longPressButton);
                    buttonContainer.appendChild(saveJpgButton);
                    buttonContainer.appendChild(cancelButton);
                    
                    // 组装对话框
                    dialogContent.appendChild(title);
                    dialogContent.appendChild(preview);
                    dialogContent.appendChild(helpText);
                    dialogContent.appendChild(buttonContainer);
                    dialogOverlay.appendChild(dialogContent);
                    
                    // 添加到页面
                    document.body.appendChild(dialogOverlay);
                    
                    // 添加事件监听
                    downloadButton.addEventListener('click', () => {
                        this.downloadImage(dataURL, 'png');
                        document.body.removeChild(dialogOverlay);
                    });
                    
                    longPressButton.addEventListener('click', () => {
                        // 提示用户长按图片
                        preview.style.cssText = `
                            max-width: 100%;
                            max-height: 60vh;
                            object-fit: contain;
                            margin: 10px auto;
                            border: 2px dashed #3b82f6;
                            padding: 10px;
                        `;
                        helpText.textContent = '请长按图片 → 选择"保存图片"';
                        helpText.style.color = '#ef4444';
                        helpText.style.fontWeight = 'bold';
                        
                        // 移除按钮，只保留取消
                        buttonContainer.innerHTML = '';
                        buttonContainer.appendChild(cancelButton);
                    });
                    
                    saveJpgButton.addEventListener('click', () => {
                        this.downloadImage(this.convertToJpg(dataURL), 'jpg');
                        document.body.removeChild(dialogOverlay);
                    });
                    
                    cancelButton.addEventListener('click', () => {
                        document.body.removeChild(dialogOverlay);
                        // 关闭对话框后，自动调整视图以显示所有内容
                        setTimeout(() => {
                            zoomSystem.zoomToFitContent();
                        }, 100);
                    });
                },
                
                // 转换PNG为JPG
                convertToJpg(pngDataUrl) {
                    const img = document.createElement('img');
                    img.src = pngDataUrl;
                    
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                    
                    return canvas.toDataURL('image/jpeg', 0.9);
                },
                
                // 下载图片
                downloadImage(dataUrl, format) {
                                const link = document.createElement('a');
                    link.href = dataUrl;
                    link.download = `设计导出图.${format}`;
                    
                    // 兼容不同设备的下载方式
                    if (navigator.userAgent.match(/(iPad|iPhone|iPod)/i)) {
                        // iOS设备特殊处理
                        link.target = '_blank';
                        link.rel = 'noopener';
                        document.body.appendChild(link);
                                link.click();
                        setTimeout(() => {
                            document.body.removeChild(link);
                            tipSystem.show('下载已开始，如未自动保存，请长按图片选择"保存图片"');
                        }, 100);
                    } else {
                        // 其它设备直接下载
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        tipSystem.show(`图片已成功导出为${format.toUpperCase()}格式`);
                    }
                },
                
                // 智能提取并导出所有内容
                async saveTransparent() {
                    tipSystem.show('正在提取内容并处理图片，请稍候...');
                    
                    try {
                        // 保存当前的视口变换
                        const currentTransform = [...canvas.viewportTransform];
                        const currentZoom = zoomLevel;
                        
                        // 临时重置视口变换，以获取对象的原始位置
                            canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
                        canvas.setZoom(1);
                        
                        // 调试输出画布对象
                        const allObjects = this.debugCanvasObjects();
                        
                        // 获取要保留的对象
                        const textAndShapes = allObjects.filter(obj => obj.type !== 'image');
                        const qrcodeImages = allObjects.filter(obj => 
                            obj.type === 'image' && 
                            (obj.imageType === 'qrcode' || obj.imageType === 'qrcode_processed')
                        );
                        
                        // 所有要导出的对象
                        const objectsToExport = [...textAndShapes];
                        
                        // 如果没有发现二维码图片，尝试更宽松的查找
                        if (qrcodeImages.length === 0) {
                            console.log('没有找到明确标记为二维码的图片，尝试查找所有图片');
                            // 将所有图片都视为二维码
                            const allImages = allObjects.filter(obj => obj.type === 'image');
                            if (allImages.length > 0) {
                                // 添加所有图片对象
                                objectsToExport.push(...allImages);
                                console.log('添加了所有图片对象:', allImages.length);
                            }
                        } else {
                            // 处理所有二维码图片
                            const processedQRImages = [];
                            for (const qrcode of qrcodeImages) {
                                const processedQR = await this.processQRCode(qrcode);
                                processedQRImages.push(processedQR);
                            }
                            objectsToExport.push(...processedQRImages);
                        }
                        
                        // 如果没有可导出的内容
                        if (objectsToExport.length === 0) {
                            tipSystem.show('没有可导出的内容，请先添加文字、图形或二维码');
                            // 恢复视口变换
                            canvas.setViewportTransform(currentTransform);
                            canvas.setZoom(currentZoom);
                            return;
                        }
                        
                        console.log('准备导出的对象:', objectsToExport.length);
                        
                        // 计算所有对象的边界框
                        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                        
                        objectsToExport.forEach(obj => {
                            // 强制更新对象坐标缓存
                            obj.setCoords();
                            
                            // 获取对象的边界矩形（考虑了旋转和缩放）
                            const objBounds = obj.getBoundingRect(true); // true参数确保获取绝对位置
                            
                            // 如果对象有实际宽高
                            if (objBounds.width > 0 && objBounds.height > 0) {
                                minX = Math.min(minX, objBounds.left);
                                minY = Math.min(minY, objBounds.top);
                                maxX = Math.max(maxX, objBounds.left + objBounds.width);
                                maxY = Math.max(maxY, objBounds.top + objBounds.height);
                                
                                console.log('对象边界:', {
                                    type: obj.type,
                                    left: objBounds.left,
                                    top: objBounds.top,
                                    width: objBounds.width,
                                    height: objBounds.height
                                });
                            }
                        });
                        
                        // 检查是否有有效的边界
                        if (minX === Infinity || minY === Infinity) {
                            console.error('无法计算有效的边界框');
                            tipSystem.show('无法计算导出范围，请检查对象是否正确显示');
                            // 恢复视口变换
                            canvas.setViewportTransform(currentTransform);
                            canvas.setZoom(currentZoom);
                            return;
                        }
                        
                        // 添加边距（画布周围留白）
                        const padding = 50; // 增加边距
                        minX = Math.floor(minX - padding);
                        minY = Math.floor(minY - padding);
                        maxX = Math.ceil(maxX + padding);
                        maxY = Math.ceil(maxY + padding);
                        
                        // 计算导出画布的尺寸
                        const exportWidth = Math.max(maxX - minX, 200); // 最小200px宽
                        const exportHeight = Math.max(maxY - minY, 200); // 最小200px高
                        
                        console.log('计算的导出尺寸:', {
                            minX, minY, maxX, maxY,
                            exportWidth, exportHeight
                        });
                        
                        // 创建临时画布，使用计算出的尺寸
                        const tempCanvas = new fabric.StaticCanvas(null, {
                            width: exportWidth,
                            height: exportHeight,
                            backgroundColor: 'transparent',
                            renderOnAddRemove: false // 提高性能
                        });
                        
                        // 克隆并添加所有对象到临时画布，调整位置
                        const clonePromises = objectsToExport.map(obj => {
                            return new Promise(resolve => {
                                obj.clone(cloned => {
                                    console.log('克隆对象:', cloned.type, '原始位置:', cloned.left, cloned.top);
                                    
                                    // 调整对象位置，使其相对于新的画布原点
                                    cloned.set({
                                        globalCompositeOperation: 'source-over',
                                        left: cloned.left - minX,
                                        top: cloned.top - minY
                                    });
                                    
                                    console.log('调整后位置:', cloned.left, cloned.top);
                                    
                                    tempCanvas.add(cloned);
                                    resolve();
                                });
                            });
                        });
                        
                        // 等待所有对象克隆完成
                        await Promise.all(clonePromises);
                        
                        // 强制渲染临时画布
                        tempCanvas.renderAll();
                        
                        // 恢复原始视口变换
                        canvas.setViewportTransform(currentTransform);
                        canvas.setZoom(currentZoom);
                        canvas.renderAll();
                        
                        // 生成高质量图片
                        const dataURL = tempCanvas.toDataURL({ 
                            format: 'png',
                            multiplier: 3, // 提高导出质量
                            quality: 1.0, // 最高质量
                            enableRetinaScaling: false // 避免缩放问题
                        });
                        
                        // 显示导出对话框
                        this.showExportDialog(dataURL);
                        
                        const imageCount = objectsToExport.filter(obj => obj.type === 'image').length;
                        tipSystem.show(`内容提取完成: 包含${textAndShapes.length}个文字/图形和${imageCount}个图片`);
                    } catch (error) {
                        console.error('导出过程中出错:', error);
                        tipSystem.show('导出过程中出现错误，请重试');
                        
                        // 确保恢复视口变换
                        try {
                            canvas.setViewportTransform(currentTransform);
                            canvas.setZoom(currentZoom);
                        } catch (e) {
                            console.error('恢复视口变换失败:', e);
                        }
                    }
                }
            };

            // 安全地绑定事件
            function safeAddEventListener(element, event, handler) {
                if (element) {
                    element.addEventListener(event, handler);
                } else {
                    console.warn(`无法绑定事件，元素不存在: ${event}`);
                }
            }
            
            // 事件绑定 - 使用安全包装器
            safeAddEventListener(elements.addShapeBtn, 'click', () => shapeSystem.createShape());
            safeAddEventListener(elements.addText, 'click', () => textSystem.addText());
            // 绑定图形参数输入框
            safeAddEventListener(elements.rectWidth, 'input', () => sizeSync.updateShape());
            safeAddEventListener(elements.rectHeight, 'input', () => sizeSync.updateShape());
            safeAddEventListener(elements.circleDiameter, 'input', () => sizeSync.updateShape());
            safeAddEventListener(elements.triangleBase, 'input', () => sizeSync.updateShape());
            safeAddEventListener(elements.triangleHeight, 'input', () => sizeSync.updateShape());
            safeAddEventListener(elements.lineLength, 'input', () => sizeSync.updateShape());
            safeAddEventListener(elements.fontFamily, 'change', () => sizeSync.updateShape());
            // 已移除字号输入框
            safeAddEventListener(elements.textContent, 'input', () => sizeSync.updateShape());
            safeAddEventListener(elements.imageUpload, 'change', (e) => imageSystem.uploadImage(e));
            safeAddEventListener(elements.saveBtn, 'click', () => saveSystem.saveTransparent());
            
            // 缩放控制
            elements.zoomIn.addEventListener('click', () => zoomSystem.zoomIn());
            elements.zoomOut.addEventListener('click', () => zoomSystem.zoomOut());
            elements.zoomReset.addEventListener('click', () => zoomSystem.resetZoom());
            elements.zoomFit.addEventListener('click', () => zoomSystem.zoomToFitContent());
            elements.enlargeObject.addEventListener('click', () => zoomSystem.enlargeSelectedObject());
            elements.shrinkObject.addEventListener('click', () => zoomSystem.shrinkSelectedObject());
            
            // 支持鼠标滚轮缩放
            canvasEl.addEventListener('wheel', (e) => {
                e.preventDefault();
                if (e.deltaY < 0) {
                    zoomSystem.zoomIn();
                } else {
                    zoomSystem.zoomOut();
                }
            });
            
            elements.deleteBtn.addEventListener('click', () => {
                const active = canvas.getActiveObject();
                if (active) {
                    canvas.remove(active);
                    tipSystem.show('已删除选中元素');
                } else {
                    tipSystem.show('请先选择要删除的元素');
                }
            });
            
            // 画布事件监听
            canvas.on('selection:created', (e) => {
                const obj = e.target;
                sizeSync.syncFromObject(obj);
                
                if (obj.type === 'text') {
                    tipSystem.show('已选择文字，可编辑内容和调整大小');
                } else if (obj.type === 'image') {
                    tipSystem.show('已选择图片，可调整位置和大小');
                } else {
                    tipSystem.show('已选择图形，可调整位置和大小');
                }
            });
            
            canvas.on('selection:updated', (e) => {
                sizeSync.syncFromObject(e.target);
            });
            
            canvas.on('selection:cleared', () => {
                tipSystem.show('取消选择');
            });
            
            // 全局边界检查函数 - 放宽限制版
            function enforceObjectBoundaries(obj) {
                if (!obj) return obj;
                
                // 获取当前画布尺寸
                const canvasWidth = canvas.width / zoomLevel;
                const canvasHeight = canvas.height / zoomLevel;
                
                // 获取对象的实际尺寸
                const objWidth = obj.getScaledWidth();
                const objHeight = obj.getScaledHeight();
                
                // 放宽边界计算 - 只要对象有一部分在画布内就允许
                // 至少保留对象的20%在画布内
                const minVisiblePart = 0.2;
                const boundsLeft = objWidth * (1 - minVisiblePart);
                const boundsTop = objHeight * (1 - minVisiblePart);
                const boundsRight = canvasWidth - objWidth * minVisiblePart;
                const boundsBottom = canvasHeight - objHeight * minVisiblePart;
                
                let positionChanged = false;
                
                // 对于大型对象特殊处理
                const isLargeObject = objWidth > canvasWidth/2 || objHeight > canvasHeight/2;
                
                // 只在严重超出边界时才限制，对大型对象更宽松
                if (obj.left < -objWidth/2) {
                    obj.left = -objWidth/2 + 10; // 留一点边缘可见
                    positionChanged = true;
                }
                if (obj.left > canvasWidth + objWidth/2) {
                    obj.left = canvasWidth + objWidth/2 - 10;
                    positionChanged = true;
                }
                if (obj.top < -objHeight/2) {
                    obj.top = -objHeight/2 + 10;
                    positionChanged = true;
                }
                if (obj.top > canvasHeight + objHeight/2) {
                    obj.top = canvasHeight + objHeight/2 - 10;
                    positionChanged = true;
                }
                
                // 只有在位置确实改变时才重新渲染
                if (positionChanged) {
                    canvas.requestRenderAll();
                }
                
                // 记录对象的安全尺寸
                obj.lastSafeScaleX = obj.scaleX;
                obj.lastSafeScaleY = obj.scaleY;
                
                return obj;
            }

            // 优化的对象移动处理 - 放宽限制版
            let movingTipTimeout = null;
            let movingState = {
                nearBoundary: false,
                lastTipTime: 0
            };
            
            canvas.on('object:moving', (e) => {
                const obj = e.target;
                // 获取对象的实际尺寸
                const objWidth = obj.getScaledWidth();
                const objHeight = obj.getScaledHeight();
                
                // 获取当前画布尺寸
                const canvasWidth = canvas.width / zoomLevel;
                const canvasHeight = canvas.height / zoomLevel;
                
                // 对于大型对象特殊处理
                const isLargeObject = objWidth > canvasWidth/2 || objHeight > canvasHeight/2;
                
                // 只在严重超出边界时才限制，对大型对象更宽松
                let posChanged = false;
                
                // 只在完全超出画布时才限制移动
                if (obj.left < -objWidth/2) {
                    obj.left = -objWidth/2 + 10; // 留一点边缘可见
                    posChanged = true;
                }
                if (obj.left > canvasWidth + objWidth/2) {
                    obj.left = canvasWidth + objWidth/2 - 10;
                    posChanged = true;
                }
                if (obj.top < -objHeight/2) {
                    obj.top = -objHeight/2 + 10;
                    posChanged = true;
                }
                if (obj.top > canvasHeight + objHeight/2) {
                    obj.top = canvasHeight + objHeight/2 - 10;
                    posChanged = true;
                }
                
                // 只有位置真正改变时才调用set
                if (posChanged) {
                    // 直接修改属性而不是使用set方法，减少重绘
                    canvas.requestRenderAll();
                }
                
                // 节流提示显示，避免频繁更新UI
                const now = Date.now();
                
                // 检查是否接近边界 - 放宽判断条件
                const margin = 20; // 放大判断边距
                const isNearBoundary = (
                    obj.left < 0 || 
                    obj.left > canvasWidth || 
                    obj.top < 0 || 
                    obj.top > canvasHeight
                );
                
                // 只在状态变化或超过时间间隔时更新提示
                if ((isNearBoundary !== movingState.nearBoundary || 
                    now - movingState.lastTipTime > 1000) && posChanged) {
                    
                    if (movingTipTimeout) {
                        clearTimeout(movingTipTimeout);
                    }
                    
                    movingTipTimeout = setTimeout(() => {
                        if (isNearBoundary) {
                            tipSystem.show('对象部分超出画布边界');
                        } else {
                            tipSystem.show('正在移动对象');
                        }
                        movingState.nearBoundary = isNearBoundary;
                        movingState.lastTipTime = now;
                    }, 200); // 延长显示延迟，减少频繁提示
                }
            });
            
            // 对象缩放功能已禁用
            
            // 在对象修改后检查边界（减少频率以提高性能）
            canvas.on('object:modified', (e) => {
                // 不再调用 enforceObjectBoundaries，避免位置跳动
                // enforceObjectBoundaries(e.target);
            });
            
            // 文本编辑事件恢复
            canvas.on('text:editing:entered', () => {
                tipSystem.show('正在编辑文字，点击空白处完成');
            });
            
            canvas.on('text:editing:exited', (e) => {
                elements.textContent.value = e.target.text;
                tipSystem.show('文字编辑完成');
            });

            // 调整canvas-wrapper大小，确保画布可见且居中
            const fitCanvasToScreen = () => {
                // 保存当前的视口变换
                const currentTransform = canvas.viewportTransform ? [...canvas.viewportTransform] : [1, 0, 0, 1, 0, 0];
                const currentZoom = zoomLevel;
                
                // 获取当前窗口的尺寸
                const windowWidth = window.innerWidth;
                const windowHeight = window.innerHeight;
                
                // 如果工具栏可见，考虑其高度
                let availableHeight = windowHeight;
                if (appState.toolbarVisible) {
                    const toolbarHeight = elements.toolbarContainer.offsetHeight || 0;
                    availableHeight -= toolbarHeight;
                    document.getElementById('canvas-wrapper').style.paddingTop = `${toolbarHeight}px`;
                } else {
                    document.getElementById('canvas-wrapper').style.paddingTop = '0';
                }
                
                // 设置画布尺寸为窗口尺寸
                canvas.setWidth(windowWidth);
                canvas.setHeight(availableHeight);
                
                // 恢复之前的缩放和视口变换
                canvas.setZoom(currentZoom);
                canvas.setViewportTransform(currentTransform);
                
                // 更新缩放指示器
                if (elements.zoomIndicator) {
                    elements.zoomIndicator.textContent = `缩放: ${Math.round(zoomLevel * 100)}%`;
                }
                
                // 确保画布渲染
                canvas.requestRenderAll();
                
                console.log('fitCanvasToScreen - 保持视口变换:', currentTransform, '缩放:', currentZoom);
            };
            
            // 初始化画布尺寸
            fitCanvasToScreen();
            
            // 初始化渲染
            canvas.renderAll();
            
            // 强制刷新画布对象的显示状态
            setTimeout(() => {
                console.log("强制刷新画布...");
                canvas.discardActiveObject();
                canvas.forEachObject(obj => {
                    obj.set({
                        dirty: true,
                        visible: true,
                        opacity: 1
                    });
                });
                canvas.renderAll();
            }, 500);
            
            // 应用全局对象设置，针对不同类型对象区别处理
            function applyNoResizeSettings() {
                canvas.forEachObject(obj => {
                    // 基本设置对所有对象应用
                    let settings = {
                        hasBorders: true,
                        selectable: true,
                        visible: true
                    };
                    
                    // 检查对象类型
                    if (obj.type === 'image' || obj.type === 'text') {
                        // 图片和文字对象允许缩放
                        Object.assign(settings, {
                            lockScalingX: false,
                            lockScalingY: false,
                            hasControls: true,
                            cornerSize: 10,
                            cornerColor: '#3b82f6',
                            cornerStyle: 'circle',
                            transparentCorners: false,
                            lockRotation: true,
                            lockSkewingX: true,
                            lockSkewingY: true
                        });
                    } else {
                        // 其他图形对象禁用缩放
                        Object.assign(settings, {
                            lockScalingX: true,
                            lockScalingY: true,
                            hasControls: false
                        });
                    }
                    
                    // 应用设置
                    obj.set(settings);
                });
                canvas.requestRenderAll();
            }
            
                            // 为所有新添加的对象应用设置并确保可见性，为图片保留缩放点
            canvas.on('object:added', function(e) {
                const obj = e.target;
                
                // 基本设置对所有对象应用
                let settings = {
                    hasBorders: true,
                    selectable: true,
                    visible: true,
                    opacity: 1
                };
                
                // 检查对象类型
                if (obj.type === 'image' || obj.type === 'text') {
                    // 图片和文字对象允许缩放
                    Object.assign(settings, {
                        lockScalingX: false,
                        lockScalingY: false,
                        hasControls: true,
                        cornerSize: 10,
                        cornerColor: '#3b82f6',
                        cornerStyle: 'circle',
                        transparentCorners: false,
                        lockRotation: true,
                        lockSkewingX: true,
                        lockSkewingY: true,
                        lockUniScaling: false
                    });
                } else {
                    // 其他图形对象禁用缩放
                    Object.assign(settings, {
                        lockScalingX: true,
                        lockScalingY: true,
                        hasControls: false
                    });
                }
                
                // 应用设置
                obj.set(settings);
                
                // 确保立即渲染所有对象
                canvas.renderAll();
                setTimeout(() => canvas.renderAll(), 50); // 额外的重新渲染，确保显示
            });
            
            // 初始应用设置
            applyNoResizeSettings();
            
            // 确保对象缩放按钮正常显示
            if (elements.enlargeObject) elements.enlargeObject.style.display = '';
            if (elements.shrinkObject) elements.shrinkObject.style.display = '';
            
            // 添加多点触控手势缩放支持
            let initialDistance = 0;
            let initialScale = { x: 1, y: 1 };
            let isScaling = false;
            let activeObjectBeforeGesture = null;
            let initialZoomLevel = 1; // 新增：记录初始画布缩放级别
            let isCanvasZooming = false; // 新增：标记是否正在缩放画布
            
            // 添加原生触摸事件监听器以支持画布缩放
            let touches = [];
            let lastScale = 1;
            let isPinching = false;
            
            // 计算两个触摸点之间的距离
            function getTouchDistance(touch1, touch2) {
                const dx = touch1.clientX - touch2.clientX;
                const dy = touch1.clientY - touch2.clientY;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            // 简化的触摸缩放实现
            let touchStartDistance = 0;
            let startZoom = 1;
            
            // 单指拖动画布的变量
            let isPanning = false;
            let panStartPoint = { x: 0, y: 0 };
            let lastPanPoint = { x: 0, y: 0 };
            let viewportTransform = [...canvas.viewportTransform]; // 复制初始变换矩阵
            let touchMoved = false; // 新增：标记是否已经移动
            let touchStartTime = 0; // 新增：记录触摸开始时间
            
            // 辅助函数：检查点击位置是否有对象
            function checkTargetAtPoint(e, touch) {
                const pointer = canvas.getPointer(e, true);
                const target = canvas.findTarget(e);
                console.log('检查位置的对象:', target ? target.type : '无');
                return target;
            }
            
            // 处理画布缩放的触摸事件
            const handleTouchStart = function(e) {
                console.log('=== handleTouchStart ===', '触摸点数:', e.touches.length);
                
                // 重置状态
                touchMoved = false;
                touchStartTime = Date.now();
                
                if (e.touches.length === 2) {
                    // 双指缩放模式
                    isPanning = false; // 停止平移
                    touchStartDistance = getTouchDistance(e.touches[0], e.touches[1]);
                    startZoom = zoomLevel;
                    isPinching = true;
                    
                    console.log('双指缩放开始，初始距离:', touchStartDistance, '初始缩放:', startZoom);
                    tipSystem.show('双指缩放画布');
                    
                    e.preventDefault();
                    e.stopPropagation();
                } else if (e.touches.length === 1) {
                    // 单指触摸 - 先记录位置，但不立即进入平移模式
                    const touch = e.touches[0];
                    panStartPoint = { x: touch.clientX, y: touch.clientY };
                    lastPanPoint = { x: touch.clientX, y: touch.clientY };
                    
                    // 不要阻止默认行为，让fabric.js也能接收到事件
                    console.log('单指触摸开始，等待判断是选择还是平移');
                }
            };
            
            const handleTouchMove = function(e) {
                if (e.touches.length === 2 && isPinching && touchStartDistance > 0) {
                    // 双指缩放逻辑（改进版本）
                    const currentDistance = getTouchDistance(e.touches[0], e.touches[1]);
                    const scale = currentDistance / touchStartDistance;
                    const newZoom = startZoom * scale;
                    
                    console.log('缩放移动 - 距离:', currentDistance, '比例:', scale.toFixed(2), '新缩放:', newZoom.toFixed(2));
                    
                    // 限制缩放范围
                    if (newZoom >= minZoom && newZoom <= maxZoom) {
                        // 使用防抖机制避免频繁缩放
                        if (!zoomSystem.isZooming) {
                            zoomLevel = newZoom;
                            
                            // 使用稳定的缩放方式，避免视图跳转
                            canvas.setZoom(zoomLevel);
                            
                            // 保持画布尺寸为窗口尺寸
                            const windowWidth = window.innerWidth;
                            const windowHeight = window.innerHeight;
                            canvas.setDimensions({
                                width: windowWidth,
                                height: windowHeight
                            });
                            
                            // 渲染画布
                            canvas.renderAll();
                            
                            // 更新UI
                            document.getElementById('zoomIndicator').textContent = `缩放: ${Math.round(zoomLevel * 100)}%`;
                            document.getElementById('zoomIndicator').style.display = 'block';
                            document.querySelector('.zoom-controls').style.display = 'flex';
                        }
                    }
                    
                    e.preventDefault();
                    e.stopPropagation();
                } else if (e.touches.length === 1 && !isPinching) {
                    // 单指移动
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - panStartPoint.x;
                    const deltaY = touch.clientY - panStartPoint.y;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    // 如果已经开始平移，继续平移
                    if (isPanning) {
                        // 增加移动灵敏度倍数
                        const sensitivity = 2.5;
                        const amplifiedDeltaX = deltaX * sensitivity;
                        const amplifiedDeltaY = deltaY * sensitivity;
                        
                        // 更新画布位置（使用初始保存的变换加上放大后的位移）
                        const newTransform = [...viewportTransform];
                        newTransform[4] = viewportTransform[4] + amplifiedDeltaX; // X偏移
                        newTransform[5] = viewportTransform[5] + amplifiedDeltaY; // Y偏移
                        
                        canvas.setViewportTransform(newTransform);
                        canvas.requestRenderAll();
                        
                        if (distance > 5) { // 移动超过5像素才显示提示
                            tipSystem.show(`移动画布: ${Math.round(amplifiedDeltaX)}px, ${Math.round(amplifiedDeltaY)}px`);
                        }
                        
                        e.preventDefault();
                        e.stopPropagation();
                    } else if (distance > 15 && !touchMoved && !canvas.getActiveObject()) {
                        // 移动超过15像素，且没有选中对象，开始平移
                        touchMoved = true;
                        isPanning = true;
                        viewportTransform = [...canvas.viewportTransform];
                        
                        // 显示移动模式指示器
                        const indicator = document.getElementById('pan-indicator');
                        if (indicator) {
                            indicator.style.display = 'block';
                        }
                        
                        console.log('检测到拖动，开始平移画布');
                        tipSystem.show('拖动画布');
                    }
                }
            };
            
            const handleTouchEnd = function(e) {
                console.log('=== handleTouchEnd ===', '剩余触摸点:', e.touches.length);
                
                if (isPinching) {
                    isPinching = false;
                    touchStartDistance = 0;
                    
                    tipSystem.show(`画布缩放: ${Math.round(zoomLevel * 100)}%`);
                    console.log('缩放结束，最终缩放:', zoomLevel);
                    
                    // 隐藏控制器
                    setTimeout(() => {
                        document.querySelector('.zoom-controls').style.display = 'none';
                        document.getElementById('zoomIndicator').style.display = 'none';
                    }, 3000);
                } else if (isPanning) {
                    isPanning = false;
                    
                    // 保存最终的变换状态
                    viewportTransform = [...canvas.viewportTransform];
                    mouseViewportTransform = [...canvas.viewportTransform]; // 同步更新鼠标拖动的变换
                    
                    // 隐藏移动模式指示器
                    document.getElementById('pan-indicator').style.display = 'none';
                    
                    tipSystem.show('画布移动完成');
                    console.log('平移结束，最终变换:', viewportTransform);
                } else if (!touchMoved && Date.now() - touchStartTime < 300) {
                    // 短时间点击，可能是选择对象
                    console.log('检测到点击，让fabric处理选择');
                }
                
                // 重置状态
                touchMoved = false;
                touchStartTime = 0;
            };
            
            // 绑定触摸事件到画布容器（而不是canvas元素）
            const canvasWrapper = document.getElementById('canvas-wrapper');
            // 使用fabric的上层画布元素来处理触摸
            const upperCanvas = canvas.upperCanvasEl || canvasEl;
            
            // 优先绑定到upperCanvas
            upperCanvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            upperCanvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            upperCanvas.addEventListener('touchend', handleTouchEnd, { passive: false });
            upperCanvas.addEventListener('touchcancel', handleTouchEnd, { passive: false });
            
            // 备用绑定到wrapper
            canvasWrapper.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvasWrapper.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvasWrapper.addEventListener('touchend', handleTouchEnd, { passive: false });
            canvasWrapper.addEventListener('touchcancel', handleTouchEnd, { passive: false });
            
            // 监听触摸开始事件（保留原有的对象缩放功能）
            canvas.on('touch:gesture', function(opt) {
                if (opt.e.type === 'touchstart' && opt.e.touches && opt.e.touches.length >= 2) {
                    // 记录初始状态
                    const touch1 = opt.e.touches[0];
                    const touch2 = opt.e.touches[1];
                    initialDistance = Math.sqrt(
                        Math.pow(touch2.clientX - touch1.clientX, 2) + 
                        Math.pow(touch2.clientY - touch1.clientY, 2)
                    );
                    
                    // 获取当前激活对象
                    const activeObj = canvas.getActiveObject();
                    if (activeObj) {
                        // 有选中对象，缩放对象
                        activeObjectBeforeGesture = activeObj;
                        initialScale = { 
                            x: activeObj.scaleX || 1, 
                            y: activeObj.scaleY || 1 
                        };
                        isScaling = true;
                        isCanvasZooming = false;
                        
                        // 临时解除缩放锁定以允许手势缩放
                        activeObj.set({
                            lockScalingX: false,
                            lockScalingY: false
                        });
                        
                        tipSystem.show('双指缩放对象');
                    }
                    
                    // 阻止默认行为避免浏览器缩放
                    opt.e.preventDefault();
                }
            });
            
            // 监听触摸移动和缩放手势
            canvas.on('touch:gesture', function(opt) {
                if (opt.e.touches && opt.e.touches.length >= 2 && isScaling && activeObjectBeforeGesture) {
                    // 计算新的距离和缩放比例
                    const touch1 = opt.e.touches[0];
                    const touch2 = opt.e.touches[1];
                    const currentDistance = Math.sqrt(
                        Math.pow(touch2.clientX - touch1.clientX, 2) + 
                        Math.pow(touch2.clientY - touch1.clientY, 2)
                    );
                    
                    // 计算缩放比例变化
                    const scaleFactor = currentDistance / initialDistance;
                    
                    // 缩放对象（保持原有逻辑）
                    // 应用新的缩放值
                    const newScaleX = initialScale.x * scaleFactor;
                    const newScaleY = initialScale.y * scaleFactor;
                    
                    // 检查是否超出最大最小限制
                    const objWidth = activeObjectBeforeGesture.width;
                    const objHeight = activeObjectBeforeGesture.height;
                    const canvasWidth = canvas.width / zoomLevel;
                    const canvasHeight = canvas.height / zoomLevel;
                    
                    // 最大允许尺寸为画布的3倍
                    const maxSizeFactor = 3; 
                    // 最小尺寸为5个像素
                    const minSize = 5;
                    
                    const newWidth = objWidth * newScaleX;
                    const newHeight = objHeight * newScaleY;
                    
                    // 检查尺寸限制
                    if (newWidth > canvasWidth * maxSizeFactor || newHeight > canvasHeight * maxSizeFactor) {
                        // 超出最大尺寸，不应用
                        return;
                    }
                    
                    if (newWidth < minSize || newHeight < minSize) {
                        // 小于最小尺寸，不应用
                        return;
                    }
                    
                    // 安全应用新的缩放
                    activeObjectBeforeGesture.set({
                        scaleX: newScaleX,
                        scaleY: newScaleY
                    });
                    
                    // 特殊处理文字对象
                    if (activeObjectBeforeGesture.type === 'text') {
                        // 更新字体大小
                        const newFontSize = activeObjectBeforeGesture.fontSize * scaleFactor;
                        if (newFontSize >= 8) { // 最小字体大小
                            activeObjectBeforeGesture.set({
                                fontSize: newFontSize
                            });
                        }
                    }
                    
                    // 特殊处理图形对象，更新宽高输入框
                    if (['rect', 'triangle', 'circle', 'line'].includes(activeObjectBeforeGesture.type)) {
                        if (activeObjectBeforeGesture.type === 'circle') {
                            const effectiveDiameter = Math.round(activeObjectBeforeGesture.radius * activeObjectBeforeGesture.scaleX * 2 / (MM_TO_PIXEL * SCALE_FACTOR));
                            elements.circleDiameter.value = effectiveDiameter;
                            elements.circleRadius.value = Math.round(effectiveDiameter / 2);
                        } else if (activeObjectBeforeGesture.type === 'rect') {
                            elements.rectWidth.value = Math.round(activeObjectBeforeGesture.width * activeObjectBeforeGesture.scaleX / (MM_TO_PIXEL * SCALE_FACTOR));
                            elements.rectHeight.value = Math.round(activeObjectBeforeGesture.height * activeObjectBeforeGesture.scaleY / (MM_TO_PIXEL * SCALE_FACTOR));
                        } else if (activeObjectBeforeGesture.type === 'triangle') {
                            elements.triangleBase.value = Math.round(activeObjectBeforeGesture.width * activeObjectBeforeGesture.scaleX / (MM_TO_PIXEL * SCALE_FACTOR));
                            elements.triangleHeight.value = Math.round(activeObjectBeforeGesture.height * activeObjectBeforeGesture.scaleY / (MM_TO_PIXEL * SCALE_FACTOR));
                        } else if (activeObjectBeforeGesture.type === 'line') {
                            elements.lineLength.value = Math.round(activeObjectBeforeGesture.width * activeObjectBeforeGesture.scaleX / (MM_TO_PIXEL * SCALE_FACTOR));
                        }
                    }
                    
                    canvas.renderAll();
                    
                    // 阻止默认行为
                    opt.e.preventDefault();
                }
            });
            
            // 监听触摸结束事件
            canvas.on('touch:gesture', function(opt) {
                if (opt.e.type === 'touchend' || opt.e.type === 'touchcancel' || opt.e.touches.length < 2) {
                    if (isScaling && activeObjectBeforeGesture) {
                        // 恢复非图片对象的缩放锁定
                        if (activeObjectBeforeGesture.type !== 'image' && activeObjectBeforeGesture.type !== 'text') {
                            activeObjectBeforeGesture.set({
                                lockScalingX: true,
                                lockScalingY: true,
                                hasControls: false
                            });
                        }
                        
                        // 文字大小已经在移动过程中更新
                        
                        canvas.renderAll();
                        tipSystem.show('已完成对象缩放');
                        
                        // 不再调用 enforceObjectBoundaries，避免位置跳动
                        // enforceObjectBoundaries(activeObjectBeforeGesture);
                        
                        // 重置状态
                        isScaling = false;
                        initialDistance = 0;
                        activeObjectBeforeGesture = null;
                    }
                }
            });
            
            // 优化拖动性能
            fabric.Object.prototype.set({
                cornerSize: 8,
                transparentCorners: false,
                cornerColor: '#3b82f6',
                cornerStrokeColor: '#ffffff',
                borderColor: '#3b82f6',
                borderDashArray: [4, 4]
            });
            
            // 设置自定义鼠标样式，提高直观性
            canvasEl.style.cursor = 'grab';
            canvas.on('mouse:down', () => canvasEl.style.cursor = 'grabbing');
            canvas.on('mouse:up', () => canvasEl.style.cursor = 'grab');
            canvas.on('mouse:out', () => canvasEl.style.cursor = 'default');
            
            // 优化触摸拖动
            canvas.on('touch:gesture', function(e) {
                if (e.e.touches && e.e.touches.length === 1) {
                    // 单指拖动优化
                    e.e.preventDefault();
                }
            });
            
            // 使用requestAnimationFrame进行画布渲染
            function optimizedRender() {
                if (canvas.isRendering) {
                    return;
                }
                canvas.isRendering = true;
                requestAnimationFrame(() => {
                    canvas.renderAll();
                    canvas.isRendering = false;
                });
            }
            
            // 恢复原始渲染，确保对象正确显示
            /*
            const originalRenderAll = canvas.renderAll;
            canvas.renderAll = function() {
                optimizedRender();
            };
            */
            
            // 监听窗口尺寸变化，重新调整画布大小
            window.addEventListener('resize', fitCanvasToScreen);
            
            // 绑定工具栏事件 - 直接DOM访问
            document.getElementById('toggleToolbar').onclick = function() {
                console.log('工具栏按钮被点击');
                
                // 直接获取DOM元素而不使用缓存
                const toolbar = document.getElementById('toolbarContainer');
                
                // 切换工具栏显示状态
                if (toolbar.style.display === 'none') {
                    toolbar.style.display = 'block';
                    this.textContent = '关闭';
                    
                    // 获取工具栏高度，调整画布位置
                    setTimeout(() => {
                        const toolbarHeight = toolbar.offsetHeight;
                        document.getElementById('canvas-wrapper').style.paddingTop = `${toolbarHeight}px`;
                        console.log('工具栏高度:', toolbarHeight, 'px');
                    }, 50);
                } else {
                    toolbar.style.display = 'none';
                    this.textContent = '工具';
                    document.getElementById('canvas-wrapper').style.paddingTop = '0';
                }
                
                // 更新全局状态
                appState.toolbarVisible = (toolbar.style.display === 'block');
                
                // 调整画布大小
                setTimeout(fitCanvasToScreen, 100);
                
                return false;
            };
            
            // 监听屏幕方向变化
            window.addEventListener('orientationchange', () => {
                // 方向变化时，延迟执行以确保尺寸已更新
                setTimeout(fitCanvasToScreen, 100);
            });
            
            // 禁止页面滚动，确保全屏体验
            document.body.addEventListener('touchmove', function(e) {
                if (e.target !== canvasEl) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            // 显示初始操作提示
            tipSystem.show('欢迎使用设计工具，点击"工具"按钮显示工具栏', 3000);
            
            // 移除自动显示代码

            // 禁用右键菜单
            canvas.on('mouse:down', function(opt) {
                const evt = opt.e;
                if (evt.button === 2) {  // 右键点击
                    evt.preventDefault();
                }
            });

            // 禁用默认右键菜单
            document.getElementById('canvas-wrapper').addEventListener('contextmenu', function(e) {
                e.preventDefault();
                return false;
            });

            // 添加鼠标拖动画布功能（用于电脑端）
            let isMousePanning = false;
            let mouseStartPoint = { x: 0, y: 0 };
            let lastMousePoint = { x: 0, y: 0 };
            let mouseViewportTransform = [...canvas.viewportTransform];
            
            // 使用中键或按住空格键+左键拖动画布
            canvasWrapper.addEventListener('mousedown', function(e) {
                // 中键拖动或按住空格键+左键拖动
                if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
                    const target = canvas.findTarget(e);
                    
                    if (!target || e.shiftKey) {
                        isMousePanning = true;
                        mouseStartPoint = { x: e.clientX, y: e.clientY };
                        lastMousePoint = { x: e.clientX, y: e.clientY };
                        mouseViewportTransform = [...canvas.viewportTransform];
                        
                        canvas.selection = false; // 禁用选择
                        canvasEl.style.cursor = 'grabbing';
                        
                        tipSystem.show('拖动画布（Shift+拖动 或 中键拖动）');
                        
                        e.preventDefault();
                        e.stopPropagation();
                    }
                }
            });
            
            window.addEventListener('mousemove', function(e) {
                if (isMousePanning) {
                    const deltaX = e.clientX - mouseStartPoint.x;
                    const deltaY = e.clientY - mouseStartPoint.y;
                    
                    // 增加移动灵敏度倍数（与触摸保持一致）
                    const sensitivity = 1.0;
                    const amplifiedDeltaX = deltaX * sensitivity;
                    const amplifiedDeltaY = deltaY * sensitivity;
                    
                    const newTransform = [...mouseViewportTransform];
                    newTransform[4] = mouseViewportTransform[4] + amplifiedDeltaX;
                    newTransform[5] = mouseViewportTransform[5] + amplifiedDeltaY;
                    
                    canvas.setViewportTransform(newTransform);
                    canvas.requestRenderAll();
                    
                    lastMousePoint = { x: e.clientX, y: e.clientY };
                    
                    e.preventDefault();
                }
            });
            
            window.addEventListener('mouseup', function(e) {
                if (isMousePanning) {
                    isMousePanning = false;
                    mouseViewportTransform = [...canvas.viewportTransform];
                    
                    canvas.selection = true; // 恢复选择
                    canvasEl.style.cursor = 'grab';
                    
                    tipSystem.show('画布移动完成');
                }
            });
            
            // 添加键盘快捷键支持
            window.addEventListener('keydown', function(e) {
                // 空格键：临时切换到拖动模式
                if (e.code === 'Space' && !e.repeat) {
                    canvasEl.style.cursor = 'grab';
                    tipSystem.show('按住Shift并拖动以移动画布');
                }
                
                // R键：重置视图
                if (e.key === 'r' || e.key === 'R') {
                    canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
                    zoomLevel = 1;
                    canvas.setZoom(1);
                    tipSystem.show('视图已重置');
                }
            });
            
            window.addEventListener('keyup', function(e) {
                if (e.code === 'Space') {
                    canvasEl.style.cursor = 'default';
                }
            });
            
            // 初始化图形参数切换系统
            shapeParamsSystem.init();
        }

        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>

</html>
    